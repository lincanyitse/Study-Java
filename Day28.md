# 关联查询

## null

---

### 操作

  > null是数据库里的重要概念, 即空值

+ 设置null
  > 插入时不指定某个字段值, 数据库默认会插入null值,
  > 也可以用显式指定null值的方式;
  > 还可以使用update来设置某个字段或数据为null

>注：没有非空约束的时候才可以插入或更改为null

+ 非空约束
  > 是约束条件的一种, 用于确保数据表中某个字段值不为空。

### 函数

  > 因为null和任何数据做算数运算, 结果都是null,为了解决这一问题需要用到空值处理函数

+ `nvl(expr1,expr2)` 用于将null转变为非null值;
+ `nvl2(expr1,expr2,expr3)` 用来判断expr1是否为NULL, 如果不是NULL, 返回expr2, 如果是NULL, 返回expr3;

---

## 单表条件查询

---

### 运算符查询

  > 在WHERE子句中的查询条件, 可以使用比较运算符来做查询

+ 常用比较运算符有`>, <, >=, <=, !=, <>, =`;

### 操作符查询

+ 关系操作符`and`或`or`是在比较运算符中来取出满足所有条件或某一个条件的的数据;
+ 比较操作`in`或`not in`直接来取出符合列表范围中的数据;
+ 边界操作符`between 低值 and 高值`直接来取出符合某个值域范围条件的数据;
+ 空值判断符`is null`和`not null`直接来判断是否为空值, 使用“=”号不能判断空值;
+ 使用`any`或`all`是需要配合单行比较操作符`>, >=, <, <=`一起使用, 其中：
  + `> ANY`：大于最小 (大于任意一个)

    ```SQL
    列名 > ANY (某个列)
    ```

  + `< ANY`：小于最大 (小于任意一个)
  
    ```SQL
    列名 < ANY (某个列)
    ```
  
  + `> ALL`：大于最大 (比所有值大)
  
    ```SQL
    列名 > ALL (某个列)
    ```
  
  + `< ALL`：小于最小 (比所有值小)
  
    ```SQL
    列名 < ALL (某个列)
    ```

### 模糊查询
  
  > 在WHERE子句中的查询条件, 可以借助 LIKE 子句来实现模糊查询
  >
  > ```SQL
  > 列名 LIKE '匹配方法'
  > ```
  >
  >
  > + `%`：匹配表示0到多个字符;
  > + `_`：匹配单个字符;

### 函数或表达式查询

+ 可以使用表达式和函数来获取符合结果的数据;
+ 还可以使用`distinct 列名`过滤掉重复的数据
+ 使用`order by 列名[,列名...] [asc | desc]`对数据进行排序,并且必须出现在select中最后一个子句, 其中：
  + `asc` 用来指定升序排序;
  + `desc` 用来指定降序排序;
    > 注：当以多列作为排序标准时, 首先按照第一列进行排序, 如果第一列数据相同, 再以第二列排序, 以此类推
+ 组函数查询
    > 组函数就是将表的全部数据划分为几组数据, 每组数据统计出一个结果;
  + `max(列名)`：用来取得列或表达式的最大值;
  + `min(列名)`：用来取得列或表达式的最小值;
  + `AVG(数字类型)`：统计列或表达式的平均值, 只能操作数字类型;
  + `sum(数字类型)`：统计列或表达式的和值, 只能操作数字类型, 并且会忽略空值;
  + `count(列名)`：计算表中的记录条数, 支持通配符*, 并且会忽略空值;
  + 使用`group by 列名或表达式`对指定的列进行分组查询;
    + `having 分组条件`用来对分组后的结果进一步限制, 必须跟在`group by`后面, 不能单独存在;

> 注：查询语句的执行顺序：
>
> 1. `from` 子句：执行顺序为从后往前、从右到左, 数据量较少的表尽量放在后面;
> 2. `where` 子句：执行顺序为自下而上、从右到左, 将能过滤掉最大数量记录的条件写在`WHERE`子句的最右;
> 3. `group by` 子句：执行顺序从左往右分组, 最好在`GROUP BY`前使用`WHERE`将不需要的记录在`GROUP BY`之前过滤掉;
> 4. `having` 子句：消耗资源。尽量避免使用, `HAVING` 会在检索出所有记录之后才对结果集进行过滤, 需要排序等操作;
> 5. `select` 子句：少用号, 尽量取字段名称。`ORACLE` 在解析的过程中, 通过查询数据字典将号依次转换成所有的列名, 消耗时间;
> 6. `order by` 子句：执行顺序为从左到右排序, 消耗资源;

---

## 多表关联查询

---

### 关联的概念

> 实际应用中, 经常会需要查询两个或两个以上的表来获取所需要的数据。这种查询两个或两个以上数据表的查询叫做连接查询, 连接查询通常建立在存在相互关系的父子表之间。

+ 笛卡尔积
  > 做关联查询时有可能会出现`笛卡尔积`, `笛卡尔积`指做关联操作的每个表的每一行都和其它表的每一行做组合, 假设两个表的记录条数分别是X和Y, `笛卡尔积`将返回X * Y条记录, `笛卡尔积`会在下面条件下产生:
  > + 省略连接条件
  > + 连接条件无效
  > + 所有表中的所有行互相连接
  >
  >为了避免`笛卡尔积`,  可以在`WHERE`加入有效的连接条件;

+ 等值连接
  > 等值连接是连接查询中最常见的一种, 通常是在有关联关系的两表间建立等值连接, 并将连接条件设定为有关联关系的列, 使用等号”=”连接相关的表;

### 查询

+ 内连接(等值连接)
  > 内连接返回两个关联表中所有满足连接条件的记录;
  + 驱动表和匹配表
    > 格式：`表1 join 表2 on 条件`
  
    ```SQL
    SELECT table1.column, table2.column FROM table1 JOIN table2 on table1.column = table2.column;
    ```
  
    1. `表1`叫做`驱动表(主表、父表)`, `表2`叫做`匹配表(从表、子表)`;
    2. 等值连接方式下 , `驱动表`和`匹配表`位置可以互换 , 不影响结果集;
    3. 执行方式：不论谁做`驱动表`, 都会遍历`驱动表` , 在`匹配表`中查找匹配数据;

+ 外连接
  > 内连接返回两个表中所有满足连接条件的数据记录, 在有些情况下, 还需要返回那些不满足连接条件的记录, 要使用外连接, 即不仅返回满足连接条件的记录, 还将返回不满足连接条件的记录;

  + 左外连接
  
    ```SQL
    SELECT table1.column, table2.column FROM table1, table2 WHERE table1.column = table2.column(+);
    ```
  
  + 右外连接
  
    ```SQL
    SELECT table1.column, table2.column FROM table1, table2 WHERE table1.column(+) = table2.column;
    ```
  
  > 注：+ 表示补充, 即哪个表有加号, 这个表就是匹配表;

  + SQL：1999语法的连接
    >
    > ```SQL
    > SELECT table1.column, table2.column FROM table1 [LEFT | RIGHT| FULL] [outer] JOIN table2 ON table1.column1 = table2.column2;
    > ```
    >
    > 如果驱动表在匹配表中找不到匹配记录 , 则匹配一行空行：
    > + `外连接的结果集 = 内连接的结果集 + 驱动表在匹配表中匹 配不上的记录和空值`
    >
    > 注：外连接的本质是驱动表中的数据一个都不能少;
    + `left outer join` 以左边的表为驱动表
    + `right outer join` 以右边的表为驱动表
    + `full outer join` 全外连接,
    > 全外连接是指除了返回两个表中满足连接条件的记录, 还会返回不满足连接条件的所有其它行, 即：
    > + `全外连接的结果集 = 内连接的结果集 + 驱动表中在匹配表中找不到匹配记录的数据和 null 值 + 匹配表中在驱动表中找不到匹配记录的数据和 null 值`
    >
    >  全连接的驱动表和匹配表可以互换, 并且不支持(+);

  + 自连接
   > 自连接是一种特殊的连接查询, 数据的来源是一个表, 即关联关系来自于单表中的多个列, 自连接是通过将表用别名虚拟成两个表的方式实现, 可以是等值或不等值连接

+ 总结
  > |连接类型|定义|
  > |:---:|:---|
  > |内连接|只连接匹配的行 表1.column=表2.column|
  > |左外连接|包含左边表的全部行（不管右边的表中是否存在与它们匹配的行）, 以及右边表中全部匹配的行 表1.column=表2.column(+)或left outer join|
  > |右外连接|包含右边表的全部行（不管左边的表中是否存在与它们匹配的行）, 以及左边表中全部匹配的行 表1.column(+)=表2.column或right outer join|
  > |全外连接|包含左、右两个表的全部行, 不管另外一边的表中是否存在与它们匹配的行。 full outer join|
  > |自连接|只连接匹配的行|
